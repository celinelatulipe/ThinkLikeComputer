<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.19 -->
<document source="/Users/clatulip/Documents/RunestoneBooks/ThinkLikeComputer/_sources/DebuggingAndModules/ObjectInstances.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <substitution_definition names="blank"><BlankNode></BlankNode></substitution_definition>
    <substitution_definition names="docname"><reference refuri="ObjectInstances-source.html">ObjectInstances</reference></substitution_definition>
    <comment xml:space="preserve">Copyright (C)  Brad Miller, David Ranum, Jeffrey Elkner, Peter Wentworth, Allen B. Downey, Chris
Meyers, and Dario Mitchell.  Permission is granted to copy, distribute
and/or modify this document under the terms of the GNU Free Documentation
License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being Forward, Prefaces, and
Contributor List, no Front-Cover Texts, and no Back-Cover Texts.  A copy of
the license is included in the section entitled "GNU Free Documentation
License".</comment>
    <section ids="object-oriented-concepts" names="object\ oriented\ concepts">
        <title>Object Oriented Concepts</title>
        <paragraph>It’s been fun drawing things with the turtles. In the process, we’ve slipped in some new concepts and terms. Let’s pull them out and examine them a little more carefully. We mentioned previously, and we’ll mention it again here - the turtle module is object-oriented (as are many other modules in Python). Object-oriented programming is not the focus of this course at all. If you continue in computer science, you will learn a lot more about object-oriented programming, which is a really powerful way of thinking about the world and how to solve problems.</paragraph>
        <section ids="user-defined-classes" names="user-defined\ classes">
            <title>User-defined Classes</title>
            <paragraph>First, just as Python provides a way to define new functions in your programs, it also provides a way to define new classes of objects. Later in the book you will learn how to define functions, and in later computing courses you will learn how to define your own object classess. For now, you just need to understand how to use them.</paragraph>
        </section>
        <section ids="instances" names="instances">
            <title>Instances</title>
            <paragraph>Given a class like <literal>Turtle</literal> or <literal>Screen</literal>, we create a new instance with a syntax that looks like a function call, <literal>Turtle()</literal>. The Python interpreter figures out that Turtle is a class rather than a function, and so it creates a new instance of the class and returns it. Since the Turtle class was defined in a separate module, (confusingly, also named turtle), we had to refer to the class as turtle.Turtle. Thus, in the programs we wrote <literal>turtle.Turtle()</literal> to make a new turtle. We could also write <literal>turtle.Screen()</literal> to make a new window for our turtles to paint in.</paragraph>
        </section>
        <section ids="attributes" names="attributes">
            <title>Attributes</title>
            <paragraph>Each instance can have attributes, sometimes called <strong>instance variables</strong>. These are just like other variables in Python. We use assignment statements, with an =, to assign values to them. Thus, if alex and tess are variables bound (linked) to two instances of the class Turtle, we can assign values to an attribute, and we can look up those attributes. For example, the following code would print out 1100.</paragraph>
            <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve">alex.price = 500
tess.price = 600
print(alex.price + tess.price)</literal_block>
        </section>
        <section ids="methods" names="methods">
            <title>Methods</title>
            <paragraph>Classes have associated <strong>methods</strong>, which are just a special kind of function.  Consider the expression <literal>alex.forward(50)</literal> The interpreter first looks up alex and finds that it is an instance of the class Turtle. Then it looks up the attribute forward and finds that it is a method. Since there is a left parenthesis directly following, the interpreter invokes the method, passing 50 as a parameter.</paragraph>
            <paragraph>The only difference between a method invocation and other function calls is that the object instance itself is also passed as a parameter. Thus <literal>alex.forward(50)</literal> moves alex, while <literal>tess.forward(50)</literal> moves tess.</paragraph>
            <paragraph>Some of the methods of the Turtle class set attributes that affect the actions of other methods. For example, the method pensize changes the width of the drawing pen, and the color method changes the pen’s color.</paragraph>
            <paragraph>Methods return values, just as functions do. However, none of the methods of the Turtle class that you have used return useful values the way the <literal>len</literal> function does. Thus, it would not make sense to build a complex expression like <literal>tess.forward(50) + 75</literal>. It could make sense, however to put a complex expression inside the parentheses: <literal>tess.forward(x + y)</literal></paragraph>
        </section>
    </section>
</document>
