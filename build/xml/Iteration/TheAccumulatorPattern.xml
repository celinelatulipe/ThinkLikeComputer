<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.19 -->
<document source="/Users/clatulip/Documents/RunestoneBooks/ThinkLikeComputer/_sources/Iteration/TheAccumulatorPattern.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <substitution_definition names="blank"><BlankNode></BlankNode></substitution_definition>
    <substitution_definition names="docname"><reference refuri="TheAccumulatorPattern-source.html">TheAccumulatorPattern</reference></substitution_definition>
    <comment xml:space="preserve">Copyright (C)  Brad Miller, David Ranum, Jeffrey Elkner, Peter Wentworth, Allen B. Downey, Chris
Meyers, and Dario Mitchell.  Permission is granted to copy, distribute
and/or modify this document under the terms of the GNU Free Documentation
License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being Forward, Prefaces, and
Contributor List, no Front-Cover Texts, and no Back-Cover Texts.  A copy of
the license is included in the section entitled "GNU Free Documentation
License".</comment>
    <section ids="the-accumulator-pattern" names="the\ accumulator\ pattern">
        <title>The Accumulator Pattern</title>
        <paragraph>One common programming “pattern” is to traverse a sequence, <strong>accumulating</strong> a value as we go,
            such as the sum-so-far or the maximum-so-far. That way, at the end of the traversal we have
            accumulated a single value, such as the sum total of all the items or the largest item.</paragraph>
        <definition_list>
            <definition_list_item>
                <term>The anatomy of the accumulation pattern includes:</term>
                <definition>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph><strong>initializing</strong> an “accumulator” variable to an initial value (such as 0 if accumulating a sum)</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><strong>iterating</strong> (e.g., traversing the items in a sequence)</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><strong>updating</strong> the accumulator variable on each iteration (i.e., when processing each item in the sequence)</paragraph>
                        </list_item>
                    </bullet_list>
                </definition>
            </definition_list_item>
        </definition_list>
        <paragraph>For example, consider the following code, which computes the sum of the numbers in a list.</paragraph>

    <program label="ac4_9_1" interactive='activecode' language="python">
    
        <input>
nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
accum = 0
for w in nums:
    accum = accum + w
print(accum)
        </input>
<tests>


</tests>

    </program>
        <paragraph>In the program above, notice that the variable <literal>accum</literal> starts out with a value of 0.
            Next, the iteration is performed 10 times.  Inside the for loop, the update occurs.
            <literal>w</literal> has the value of the current item (1 the first time, then 2, then 3, etc.).
            <literal>accum</literal> is reassigned a new value: the old value plus the current value of <literal>w</literal>.</paragraph>
        <paragraph>This pattern of iterating the updating of a variable is commonly referred to as the
            <strong>accumulator pattern</strong>. We refer to the variable as the <strong>accumulator</strong>. This pattern will come up
            over and over again. Remember that the key to making it work successfully is to be sure to
            initialize the variable <strong>before</strong> you start the iteration. Once inside the iteration, it is required
            that you update the accumulator.</paragraph>
        <paragraph>Here is the same program in CodeLens.  Step through the function and watch the “running total”
            accumulate the result.</paragraph>

<program label="clens4_9_1" interactive="codelens" language="python">
    <input>
nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
accum = 0
for w in nums:
   accum = accum + w
print(accum)
    </input>
</program>
        <note>
            <paragraph>What would happen if we indented the print accum statement? Not sure? Make a prediction, then try it and find out.</paragraph>
        </note>
        <paragraph>We can utilize the range function in this situation as well. Previously, you’ve seen it used when we wanted to do repeated drawing instructions with a turtle. There we used it to iterate a certain number of times. We can do more than that though. The <literal>range</literal> function
            takes at least one input - which should be an integer - and returns a list as long as your input. While you can provide
            two inputs, we will focus on using range with just one input. With one input, range will start at zero and go up to - but
            not include - the input. Here are some examples:</paragraph>

    <program label="ac4_9_2" interactive='activecode' language="python">
    
        <input>
print("range(5): ")
for i in range(5):
  print(i)

print("range(0,5): ")
for i in range(0, 5):
  print(i)

# We can also print this out by casting `range` to a `list`:
print(list(range(5)))
print(list(range(0,5)))
        </input>
<tests>


</tests>

    </program>
        <paragraph>One important thing to know about the range function in Python 3 is that if we want to use it outside of iteration, we
            have to cast it to a list using <literal>list()</literal>.</paragraph>
        <paragraph>Here’s how you could use the range function in the previous problem.</paragraph>

    <program label="ac4_9_3" interactive='activecode' language="python">
    
        <input>
accum = 0
for w in range(11):
    accum = accum + w
print(accum)

# or, if you use two inputs for the range function

sec_accum = 0
for w in range(1,11):
    sec_accum = sec_accum + w
print(sec_accum)
        </input>
<tests>


</tests>

    </program>
        <paragraph>Because the range function is exclusive of the ending number, we have to use 11 as the function input.</paragraph>
        <paragraph>We can use the accumulation pattern to count the number of something or to sum up a total. The
            above examples only covered how to get the sum for a list, but we can also count how many items are
            in the list if we wanted to.</paragraph>

    <program label="ac4_9_4" interactive='activecode' language="python">
    
        <input>
nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
count = 0
for w in nums:
    count = count + 1
print(count)
        </input>
<tests>


</tests>

    </program>
        <paragraph>In this example we don’t make use of <literal>w</literal> even though the iterator variable (loop variable) is a necessary part of
            constructing a for loop. Instead of adding the value of <literal>w</literal> to <literal>count</literal> we add a 1 to it,
            because we’re incrementing the value of count when we iterate each time through the loop. Though in
            this scenario we could have used the <literal>len</literal> function, there are other cases later on where len
            won’t be useful but we will still need to count.</paragraph>
        <paragraph><strong>Check your understanding</strong></paragraph>

    <exercise label="question4_9_1">
        <statement>

        <paragraph>Consider the following code:</paragraph>
        <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve">nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
for w in nums:
   accum = 0
   accum = accum + w
print(accum)</literal_block>
        <paragraph>What happens if you put the initialization of accum inside the for loop as the first
            instruction in the loop?</paragraph>

        </statement>
<choices>

            <choice correct='yes'>
                <statement>
                    <p>It will print out 10 instead of 55</p>
                </statement>
                <feedback>
                    <p>The variable accum will be reset to 0 each time through the loop. Then it will add the current item. Only the last item will count.</p>
                </feedback>
            </choice>

            <choice >
                <statement>
                    <p>It will cause a run-time error</p>
                </statement>
                <feedback>
                    <p>Assignment statements are perfectly legal inside loops and will not cause an error.</p>
                </feedback>
            </choice>

            <choice >
                <statement>
                    <p>It will print out 0 instead of 55</p>
                </statement>
                <feedback>
                    <p>Good thought: the variable accum will be reset to 0 each time through the loop. But then it adds the current item.</p>
                </feedback>
            </choice>
</choices>

    </exercise>
<exercise label='pp4_9_1'   indentation='hide' language='python'><statement>
        <paragraph>Rearrange the code statements so that the program will add up the first n odd numbers where n is provided by the user. Note that indentation matters, so drag code blocks to the right if they should be indented.</paragraph>
</statement>
<blocks><block order='1' >
<cline>n_str = input('How many odd numbers would you like to add together?')</cline>
<cline>n = int(n_str)</cline>
<cline>thesum = 0</cline>
<cline>oddnumber = 1</cline>
</block><block order='3' >
<cline>for counter in range(n):</cline>
</block><block order='4' >
<cline>   thesum = thesum + oddnumber</cline>
<cline>   oddnumber = oddnumber + 2</cline>
</block><block order='2' >
<cline>print(thesum)</cline>
</block></blocks></exercise>
<exercise label="ac4_9_5">
    <statement>
        <paragraph>Write code to create a list of integers from 0 through 52 and assign that list to the variable <literal>numbers</literal>. You should use a special Python function – do not type out the whole list yourself. HINT: You can do this in one line of code!</paragraph>

    </statement>
    <program label="ac4_9_5_editor" interactive='activecode' language="python">

        <input>

=====

from unittest.gui import TestCaseGui

class myTests(TestCaseGui):

   def testOne(self):
      self.assertEqual(numbers, range(53), "Testing that numbers is a list that contains the correct elements.")

myTests().main()
        </input>
<tests>


</tests>

    </program>
</exercise>

<exercise label="ac4_9_6">
    <statement>
        <paragraph>Count the number of characters in string <literal>str1</literal>. Do not use <literal>len()</literal>. Save the number in variable <literal>numbs</literal>.</paragraph>

    </statement>
    <program label="ac4_9_6_editor" interactive='activecode' language="python">

        <input>
str1 = "I like nonsense, it wakes up the brain cells. Fantasy is a necessary ingredient in living."

=====

from unittest.gui import TestCaseGui

class myTests(TestCaseGui):

   def testEight(self):
      self.assertEqual(numbs, 90, "Testing that numbs is assigned to correct values.")
      self.assertNotIn("len(", self.getEditorText(), "Testing your code (Don't worry about actual and expected values).")

myTests().main()
        </input>
<tests>


</tests>

    </program>
</exercise>

<exercise label="ac4_9_7">
    <statement>
        <paragraph>Create a list of numbers 0 through 40 and assign this list to the variable <literal>numbers</literal>. Then, accumulate the total of the list’s values and assign that sum to the variable <literal>sum1</literal>.</paragraph>

    </statement>
    <program label="ac4_9_7_editor" interactive='activecode' language="python">

        <input>

=====

from unittest.gui import TestCaseGui

class myTests(TestCaseGui):

   def testNineA(self):
      self.assertEqual(numbers, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40], "Testing that numbers is assigned to correct values.")

   def testNineB(self):
      self.assertEqual(sum1, 820, "Testing that sum1 has the correct value.")

myTests().main()
        </input>
<tests>


</tests>

    </program>
</exercise>
    </section>
</document>
