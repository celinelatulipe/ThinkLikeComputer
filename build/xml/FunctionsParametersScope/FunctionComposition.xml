<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.19 -->
<document source="/Users/clatulip/Documents/RunestoneBooks/ThinkLikeComputer/_sources/FunctionsParametersScope/FunctionComposition.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <substitution_definition names="blank"><BlankNode></BlankNode></substitution_definition>
    <substitution_definition names="docname"><reference refuri="FunctionComposition-source.html">FunctionComposition</reference></substitution_definition>
    <comment xml:space="preserve">Copyright (C)  Brad Miller, David Ranum, Jeffrey Elkner, Peter Wentworth, Allen B. Downey, Chris
Meyers, and Dario Mitchell.  Permission is granted to copy, distribute
and/or modify this document under the terms of the GNU Free Documentation
License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being Forward, Prefaces, and
Contributor List, no Front-Cover Texts, and no Back-Cover Texts.  A copy of
the license is included in the section entitled "GNU Free Documentation
License".</comment>
    <index entries="['single',\ 'functional\ decomposition',\ 'index-0',\ '',\ None] ['single',\ 'generalization',\ 'index-0',\ '',\ None] ['single',\ 'abstraction',\ 'index-0',\ '',\ None] ['single',\ 'flow\ of\ execution',\ 'index-0',\ '',\ None] ['single',\ 'composition',\ 'index-0',\ '',\ None] ['single',\ 'function;\ composition',\ 'index-0',\ '',\ None]" inline="False"></index>
    <target refid="index-0"></target>
    <section ids="function-composition-functions-calling-functions index-0" names="function\ composition\ (functions\ calling\ functions)">
        <title>Function Composition (functions calling functions)</title>
        <paragraph>It is important to understand that each of the functions we write can be used and called from other functions we
            write. This is one of the most important ways that computer programmers take a large problem and break it down into a
            group of smaller problems. This process of breaking a problem into smaller subproblems is called <strong>functional decomposition</strong>.</paragraph>
        <paragraph>Here’s a simple example of functional decomposition using two functions. The first function called <literal>square</literal> simply
            computes the square of a given number. The second function called <literal>sum_of_squares</literal> makes use of square to compute
            the sum of three numbers that have been squared.</paragraph>

<program label="clens8_8_1" interactive="codelens" language="python">
    <input>
def square(x):
    y = x * x
    return y

def sum_of_squares(x,y,z):
    a = square(x)
    b = square(y)
    c = square(z)

    return a+b+c

a = -5
b = 2
c = 10
result = sum_of_squares(a,b,c)
print(result)
    </input>
</program>
        <paragraph>Even though this is a pretty simple idea, in practice this example illustrates many very important Python concepts,
            including local and global variables along with parameter passing. Note that the body of <literal>square</literal> is not executed
            until it is called from inside the <literal>sum_of_squares</literal> function for the first time on line 6.</paragraph>
        <paragraph>Also notice that when <literal>square</literal> is called (at Step 8, for example), there are two groups of local variables, one for
            <literal>square</literal> and one for <literal>sum_of_squares</literal>.  Each group of local variables is called a <strong>stack frame</strong>. The variables
            <literal>x</literal>, and <literal>y</literal> are local variables in both functions. These are completely different variables, even though they
            have the same name. Each function invocation creates a new frame, and variables are looked up in that frame. Notice
            that at step 9, y has the value 25 in one frame and 2 in the other.</paragraph>
        <paragraph>What happens when you to refer to variable y on line 3? Python looks up the value of y in the stack frame for the
            <literal>square</literal> function. If it didn’t find it there, it would go look in the global frame.</paragraph>
        <paragraph>In the example below, we create a turtle drawing program that uses function composition.</paragraph>

    <program label="ac8_8_1" interactive='activecode' language="python">
    
        <input>
import turtle
import random

def random_col(tur):
     """ Sets turtle to a random color """
     red = random.random()
     green = random.random()
     blue = random.random()
     tur.color(red, green, blue)


def random_location(tur):
     """ Take turtle to a random location on canvas
     Pre-conditions: Assume canvas is 400 x 400 """
     x = random.randrange(-180, 180) # get random x location
     y = random.randrange(-180, 180) # get random y location
     tur.penup()
     tur.goto(x,y) # move to location without drawing
     tur.pendown()

def draw_triangle(tur, side_length):
    """ draws a triangle in current position and color"""
    for _ in range(3):
        tur.forward(side_length)
        tur.left(120)


def draw_square(tur, side_length):
    """ draws a square in current position and color"""
    for _ in range(4):
        tur.forward(side_length)
        tur.left(90)

def draw_design(tur, side_length):
    """ draws a square with two internal triangles """
    random_location(tur)
    random_col(tur)
    draw_square(tur, side_length)
    draw_triangle(tur, side_length)
    tur.forward(side_length)
    tur.left(90)
    tur.forward(side_length)
    tur.left(90)
    draw_triangle(tur, side_length)


wn = turtle.Screen()
yan = turtle.Turtle()
yan.speed(10)

for _ in range(5):
     side = random.randrange(30, 100)
     draw_design(yan, side)
        </input>
<tests>


</tests>

    </program>
        <paragraph>The turtle example above has 5 different functions. Two of them are <strong>helper functions</strong> that move a turtle to a random location and set a turtle to draw in a random color. The other three are drawing functions that cause the turtle to draw things. The global part of the code (lines 47-53) create the window and the turtle and sets the turtle speed to 10 so the turtle draws quickly. Then there is a for loop that iterates 10 times. Each time through the loop a new random size is generated and then the draw_design() function is called with the random size. The draw_design function calls the other four functions, ane even calls the draw_triangle function twice.</paragraph>
        <paragraph><strong>Check your Understanding</strong></paragraph>

<exercise label="ac8_8_2">
    <statement>
        <paragraph><strong>1.</strong> Write two functions, one called <literal>addit</literal> and one called <literal>mult</literal>. <literal>addit</literal> takes one number as an input and adds 5. <literal>mult</literal> takes one number as an input, and multiplies that input by whatever is returned by <literal>addit</literal>, and then returns the result.</paragraph>

    </statement>
    <program label="ac8_8_2_editor" interactive='activecode' language="python">

        <input>

=====

from unittest.gui import TestCaseGui

class myTests(TestCaseGui):

   def testOne(self):
      self.assertEqual(mult(1), 6,"Testing the function mult with input 1 (should be 6)")
      self.assertEqual(mult(-2), -6, "Testing the function mult with input -2 (should be -6)")
      self.assertEqual(mult(0), 0, "Testing the function mult with input 0 (should be 0)")

   def testTwo(self):
      self.assertEqual(addit(1), 6, "Testing the function addit with input 1 (should be 6)")
      self.assertEqual(addit(-2), 3, "Testing the function addit with input -2 (should be 3)")
      self.assertEqual(addit(0), 5, "Testing the function addit with input 0 (should be 5)")

myTests().main()
        </input>
<tests>


</tests>

    </program>
</exercise>
    </section>
</document>
