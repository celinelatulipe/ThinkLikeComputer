<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.19 -->
<document source="/Users/clatulip/Documents/RunestoneBooks/ThinkLikeComputer/_sources/Conditionals/Chainedconditionals.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <substitution_definition names="blank"><BlankNode></BlankNode></substitution_definition>
    <substitution_definition names="docname"><reference refuri="Chainedconditionals-source.html">Chainedconditionals</reference></substitution_definition>
    <comment xml:space="preserve">Copyright (C)  Brad Miller, David Ranum, Jeffrey Elkner, Peter Wentworth, Allen B. Downey, Chris
Meyers, and Dario Mitchell.  Permission is granted to copy, distribute
and/or modify this document under the terms of the GNU Free Documentation
License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being Forward, Prefaces, and
Contributor List, no Front-Cover Texts, and no Back-Cover Texts.  A copy of
the license is included in the section entitled "GNU Free Documentation
License".</comment>
    <index entries="['single',\ 'chained\ conditional',\ 'index-0',\ '',\ None] ['single',\ 'conditional;\ chained',\ 'index-0',\ '',\ None]" inline="False"></index>
    <target refid="index-0"></target>
    <section ids="chained-conditionals index-0" names="chained\ conditionals">
        <title>Chained conditionals</title>
        <paragraph>Python provides an alternative way to write nested selection such as the one shown in the previous section.
            This is sometimes referred to as a <strong>chained conditional</strong>.</paragraph>
        <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve">if x &lt; y:
    print("x is less than y")
elif x &gt; y:
    print("x is greater than y")
else:
    print("x and y must be equal")</literal_block>
        <paragraph>The flow of control can be drawn in a different orientation but the resulting pattern is identical to the one shown above.</paragraph>
        <image candidates="{'*': 'Conditionals/Figures/flowchart_chained_conditional.png'}" uri="Conditionals/Figures/flowchart_chained_conditional.png"></image>
        <paragraph><literal>elif</literal> is an abbreviation of <literal>else if</literal>. Again, exactly one branch will be
            executed. There is no limit of the number of <literal>elif</literal> statements but only a
            single (and optional) final <literal>else</literal> statement is allowed and it must be the last
            branch in the statement.</paragraph>
        <image candidates="{'*': 'Conditionals/Figures/conditionals_overview.png'}" uri="Conditionals/Figures/conditionals_overview.png"></image>
        <paragraph>Each condition is checked in order. If the first is false, the next is checked,
            and so on. If one of them is true, the corresponding branch executes, and the
            statement ends. Even if more than one condition is true, only the first true
            branch executes.</paragraph>
        <paragraph>Here is the same program using <literal>elif</literal>.</paragraph>

    <program label="ac6_9_1" interactive='activecode' language="python">
    
        <input>
x = 10
y = 10

if x &lt; y:
    print("x is less than y")
elif x &gt; y:
    print("x is greater than y")
else:
    print("x and y must be equal")
        </input>
<tests>


</tests>

    </program>
        <paragraph>The following image highlights different kinds of valid conditionals that can be used. Though there are other
            versions of conditionals that Python can understand (imagine an if statement with twenty elif statements), those
            other versions must follow the same order as seen below.</paragraph>
        <image alt="shows a unary conditiona, a binary conditional, a conditional with if, elif, else, and a conditional with if, elif, and elif." candidates="{'*': 'Conditionals/Figures/valid_conditionals.png'}" uri="Conditionals/Figures/valid_conditionals.png"></image>
        <paragraph>Here is a turtle example that uses chained conditionals.</paragraph>

    <program label="ac6_9_2" interactive='activecode' language="python">
    
        <input>
import turtle
wn = turtle.Screen()

amy = turtle.Turtle()
amy.right(170)

colors = ["Pink", "Purple", "Yellow", "Orange", "Pink", "Orange", "Yellow", "Purple", "Orange", "Pink", "Pink", "Orange", "Yellow", "Purple", "Orange", "Purple", "Yellow", "Orange", "Pink", "Orange", "Purle", "Purple", "Yellow", "Orange", "Pink", "Blue", "Orange", "Yellow", "Purple"]


for color in colors:
    amy.pencolor(color)

    if amy.pencolor() == "Purple":
        amy.forward(50)
        amy.right(59)
    elif amy.pencolor() == "Yellow":
        amy.forward(65)
        amy.left(98)
    elif amy.pencolor() == "Orange":
        amy.forward(30)
        amy.left(60)
    elif amy.pencolor() == "Pink":
        amy.forward(50)
        amy.right(57)
    else:
        print("Uh-oh! I don't know the color: ", color)

amy.hideturtle()
        </input>
<tests>


</tests>

    </program>
        <paragraph>The above example combines a for loop with a set of conditional statements. Here, we loop through a list of
            colors and each iteration checks to see what amy’s pen color is. Depending on the pen color, the turtle will
            move in a certain direction, for a certain distance. This example also demonstrates a common pattern for chained
            conditionals in which all of the expected things are covered by the various <literal>elif</literal> branches, and the <literal>else</literal>
            is used to notify the programmer with a console message that something unexpected has occurred. In this case, we
            expected only the four colours purple, yellow, orange, and pink. If we get something else, we print a message out
            (and typically print out the unexpected item), which in this case helps us notice two things: there is a typo and
            “Purple” is mispelled in one spot, and there is a “Blue” in the list, and so maybe we want to add code to handle
            that color. You may think that adding such an else clause is unnecessary because you are sure your code works correctly,
            but it’s helpful more often than you think.</paragraph>
        <paragraph><strong>Check your understanding</strong></paragraph>

    <exercise label="question6_9_1">
        <statement>

        <paragraph>Which of I, II, and III below gives the same result as the following nested if?</paragraph>
        <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># nested if-else statement
x = -10
if x &lt; 0:
    print("The negative number ",  x, " is not valid here.")
else:
    if x &gt; 0:
        print(x, " is a positive number")
    else:
        print(x, " is 0")</literal_block>
        <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve">I.

if x &lt; 0:
    print("The negative number ",  x, " is not valid here.")
else (x &gt; 0):
    print(x, " is a positive number")
else:
    print(x, " is 0")</literal_block>
        <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve">II.

if x &lt; 0:
    print("The negative number ",  x, " is not valid here.")
elif (x &gt; 0):
    print(x, " is a positive number")
else:
    print(x, " is 0")</literal_block>
        <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve">III.

if x &lt; 0:
    print("The negative number ",  x, " is not valid here.")
if (x &gt; 0):
    print(x, " is a positive number")
else:
    print(x, " is 0")</literal_block>

        </statement>
<choices>

            <choice >
                <statement>
                    <p>I only</p>
                </statement>
                <feedback>
                    <p>You can not use a Boolean expression after an else.</p>
                </feedback>
            </choice>

            <choice correct='yes'>
                <statement>
                    <p>II only</p>
                </statement>
                <feedback>
                    <p>Yes, II will give the same result.</p>
                </feedback>
            </choice>

            <choice >
                <statement>
                    <p>III only</p>
                </statement>
                <feedback>
                    <p>No, III will not give the same result.  The first if statement will be true, but the second will be false, so the else part will execute.</p>
                </feedback>
            </choice>

            <choice >
                <statement>
                    <p>II and III</p>
                </statement>
                <feedback>
                    <p>No, Although II is correct III will not give the same result.  Try it.</p>
                </feedback>
            </choice>

            <choice >
                <statement>
                    <p>I, II, and III</p>
                </statement>
                <feedback>
                    <p>No, in I you can not have a Boolean expression after an else.</p>
                </feedback>
            </choice>
</choices>

    </exercise>

    <exercise label="question6_9_2">
        <statement>

        <paragraph>What will the following code print if x = 3, y = 5, and z = 2?</paragraph>
        <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve">if x &lt; y and x &lt; z:
    print("a")
elif y &lt; x and y &lt; z:
    print("b")
else:
    print("c")</literal_block>

        </statement>
<choices>

            <choice >
                <statement>
                    <p>a</p>
                </statement>
                <feedback>
                    <p>While the value in x is less than the value in y (3 is less than 5) it is not less than the value in z (3 is not less than 2).</p>
                </feedback>
            </choice>

            <choice >
                <statement>
                    <p>b</p>
                </statement>
                <feedback>
                    <p>The value in y is not less than the value in x (5 is not less than 3).</p>
                </feedback>
            </choice>

            <choice correct='yes'>
                <statement>
                    <p>c</p>
                </statement>
                <feedback>
                    <p>Since the first two Boolean expressions are false the else will be executed.</p>
                </feedback>
            </choice>
</choices>

    </exercise>

<exercise label="ac6_9_3">
    <statement>
        <paragraph>Create one conditional to find whether “false” is in string <literal>str1</literal>. If so, assign variable <literal>output</literal> the string “False. You aren’t you?”. Check to see if “true” is in string <literal>str1</literal> and if it is then assign “True! You are you!” to the variable <literal>output</literal>. If neither are in <literal>str1</literal>, assign “Neither true nor false!” to <literal>output</literal>.</paragraph>

    </statement>
    <program label="ac6_9_3_editor" interactive='activecode' language="python">

        <input>
str1 = "Today you are you! That is truer than true! There is no one alive who is you-er than you!"

=====

from unittest.gui import TestCaseGui

class myTests(TestCaseGui):

   def testThree(self):
      self.assertEqual(output, "True! You are you!", "Testing that output has the correct value, given the str1 provided.")
      self.assertIn("else", self.getEditorText(), "Testing output (Don't worry about actual and expected values).")
      self.assertIn("elif", self.getEditorText(), "Testing output (Don't worry about actual and expected values).")

myTests().main()
        </input>
<tests>


</tests>

    </program>
</exercise>

<exercise label="ac6_9_4">
    <statement>
        <paragraph>Create an empty list called <literal>resps</literal>. Using the list <literal>percent_rain</literal>, for each percent, if it is above 90, add the string ‘Bring an umbrella.’ to <literal>resps</literal>, otherwise if it is above 80, add the string ‘Good for the flowers?’ to <literal>resps</literal>, otherwise if it is above 50, add the string ‘Watch out for clouds!’ to <literal>resps</literal>, otherwise, add the string ‘Nice day!’ to <literal>resps</literal>. Note: if you’re sure you’ve got the problem right but it doesn’t pass, then check that you’ve matched up the strings exactly.</paragraph>

    </statement>
    <program label="ac6_9_4_editor" interactive='activecode' language="python">

        <input>
percent_rain = [94.3, 45, 100, 78, 16, 5.3, 79, 86]

=====

from unittest.gui import TestCaseGui

class myTests(TestCaseGui):

   def testOne(self):
      self.assertEqual(resps, ['Bring an umbrella.','Nice day!','Bring an umbrella.','Watch out for clouds!',"Nice day!",'Nice day!','Watch out for clouds!',"Good for the flowers?"], "Testing the value of resps")

myTests().main()
        </input>
<tests>


</tests>

    </program>
</exercise>

<exercise label="ac6_9_5">
    <statement>
        <paragraph>We have created conditionals for you to use. Do not change the provided conditional statements. Find an integer value for <literal>x</literal> that will cause <literal>output</literal> to hold the values <literal>True</literal> and <literal>None</literal>. (Drawing diagrams or flow charts for yourself may help!)</paragraph>

    </statement>
    <program label="ac6_9_5_editor" interactive='activecode' language="python">

        <input>
x =
output = []

if x &gt; 63:
    output.append(True)
elif x &gt; 55:
    output.append(False)
else:
    output.append("Neither")

if x &gt; 67:
    output.append(True)
else:
    output.append(None)

=====

from unittest.gui import TestCaseGui

class myTests(TestCaseGui):

   def testSixA(self):
      self.assertEqual(output, [True, None], "Testing that value of output is correct.")

   def testSixB(self):
      self.assertEqual(x in [64, 65, 66, 67], True, "Testing that value of x is reasonable for this problem")

myTests().main()
        </input>
<tests>


</tests>

    </program>
</exercise>
    </section>
</document>
