<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.19 -->
<document source="/Users/clatulip/Documents/RunestoneBooks/ThinkLikeComputer/_sources/Conditionals/Logicaloperators.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <substitution_definition names="blank"><BlankNode></BlankNode></substitution_definition>
    <substitution_definition names="docname"><reference refuri="Logicaloperators-source.html">Logicaloperators</reference></substitution_definition>
    <comment xml:space="preserve">Copyright (C)  Brad Miller, David Ranum, Jeffrey Elkner, Peter Wentworth, Allen B. Downey, Chris
Meyers, and Dario Mitchell.  Permission is granted to copy, distribute
and/or modify this document under the terms of the GNU Free Documentation
License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being Forward, Prefaces, and
Contributor List, no Front-Cover Texts, and no Back-Cover Texts.  A copy of
the license is included in the section entitled "GNU Free Documentation
License".</comment>
    <comment xml:space="preserve">index::logical operator
operator; logical
single: and
single: or
single: not</comment>
    <section ids="logical-operators" names="logical\ operators">
        <title>Logical operators</title>
        <paragraph>There are three <strong>logical operators</strong>: <literal>and</literal>, <literal>or</literal>, and <literal>not</literal>.
            All three operators take boolean operands and produce boolean values.
            The semantics (meaning) of these operators is similar to their meaning in English:</paragraph>
        <bullet_list bullet="*">
            <list_item>
                <paragraph><literal>x and y</literal> is <literal>True</literal> if both <literal>x</literal> and <literal>y</literal> are <literal>True</literal>. Otherwise, <literal>and</literal> produces <literal>False</literal>.</paragraph>
            </list_item>
            <list_item>
                <paragraph><literal>x or y</literal> yields <literal>True</literal> if either <literal>x</literal> or <literal>y</literal> is <literal>True</literal>. Only if both operands are <literal>False</literal>
                    does <literal>or</literal> yield <literal>False</literal>.</paragraph>
            </list_item>
            <list_item>
                <paragraph><literal>not x</literal> yields <literal>False</literal> if <literal>x</literal> is <literal>True</literal>, and vice versa.</paragraph>
            </list_item>
        </bullet_list>
        <paragraph>Look at the following example. See if you can predict the output. Then, run it to see if your predictions were
            correct:</paragraph>

    <program label="logop_ex1" interactive='activecode' language="python">
    
        <input>
x = True
y = False
print(x or y)
print(x and y)
print(not x)
        </input>
<tests>


</tests>

    </program>
        <paragraph>Although you can use boolean operators with simple boolean literals or variables as in the above
            example, they are often combined with the comparison operators, as in this example. Again, before you
            run this, see if you can predict the outcome:</paragraph>

    <program label="ac6_3_1" interactive='activecode' language="python">
    
        <input>
x = 5
print(x &gt; 0 and x &lt; 10)

n = 25
print(n % 2 == 0 or n % 3 == 0)
        </input>
<tests>


</tests>

    </program>
        <paragraph>The expression <literal>x &gt; 0 and x &lt; 10</literal> is <literal>True</literal> only if <literal>x</literal> is greater than 0 <emphasis>and</emphasis>
            at the same time, x is less than 10.  In other words, this expression is <literal>True</literal> if
            x is between 0 and 10, not including the endpoints.</paragraph>
        <admonition classes="admonition-common-mistake">
            <title>Common Mistake!</title>
            <paragraph>There is a very common mistake that occurs when programmers try to write boolean expressions.  For example, what if
                we have a variable <literal>number</literal> and we want to check to see if its value is 5 or 6.  In words we might say: “number
                equal to 5 or 6”.  However, if we translate this into Python, <literal>number == 5 or 6</literal>, it will not yield correct
                results. The <literal>or</literal> operator must have a complete equality check on both sides.  The correct way to write this is
                <literal>number == 5 or number == 6</literal>. Remember that both operands of <literal>or</literal> must be booleans in order to yield proper results.</paragraph>
        </admonition>
        <paragraph>The <literal>or</literal> operator is sometimes confusing to new programmers, because it operates differently than the way we use the word ‘or’
            when speaking. The sentence, ‘’Karina is going to go to grad school or look for a job in industry’’ suggests that
            Karina will do one of these two things, but will not do both. In English, the ‘or’ we typically use is what we call an ‘exclusive or’.
            But in programming, the value of an <literal>or</literal> expression is true
            if both operands are true. The <strong>only</strong> time an <literal>or</literal> expression evaluates to false is when both operands are false. In the Karina example,
            it would be true if Karina went to grad school, it would be true if Karina got a job in industry, it would be true if Karina went to grad
            school <strong>and</strong> got a job in industry. It would only be false if Karina did neither.</paragraph>

    <program label="ac6_3_2" interactive='activecode' language="python">
    
        <input>
x = 5
y = 7

print(x &lt; 10 or y &gt; 3)
        </input>
<tests>


</tests>

    </program>
        <index entries="['single',\ 'short-circuiting',\ 'index-0',\ '',\ None]" inline="False"></index>
        <target refid="index-0"></target>
        <section ids="smart-evaluation index-0" names="smart\ evaluation">
            <title>Smart Evaluation</title>
            <paragraph>Python is “smart” about the way it evaluates expressions using boolean operators. Consider the following example:</paragraph>
            <literal_block force="False" language="default" linenos="False" xml:space="preserve">answer = input('Continue?')
if answer == 'Y' or answer == 'y':
   print('Continuing!')</literal_block>
            <paragraph>There are two operands for the <literal>or</literal> operator here: <literal>answer == 'Y'</literal> and <literal>'answer == 'y'</literal>. Python evaluates from
                left to right, and if the first operand for <literal>or</literal> evaluates to <literal>True</literal>, Python doesn’t bother evaluating the second
                operand, because it knows the result must be <literal>True</literal> (recall that if either operand for <literal>or</literal> is <literal>True</literal>, the
                result is <literal>True</literal>). So, if the user enters <literal>Y</literal>, Python first evaluates <literal>answer ==
'Y'</literal>, determines that it is <literal>True</literal>, and doesn’t bother to check to see if <literal>answer == 'y'</literal> is <literal>True</literal>; it just
                concludes that the entire condition is <literal>True</literal> and executes the print statement.</paragraph>
            <paragraph>In a similar fashion, with the <literal>and</literal> operator, if the first operand evaluates to <literal>False</literal>, Python doesn’t check the
                second operand’s value, because it can conclude that the result must be <literal>False</literal>.</paragraph>
            <paragraph>This behavior, in which Python in some cases skips the evaluation of the second operand to <literal>and</literal> and <literal>or</literal>, is called
                <strong>short-circuit boolean evaluation</strong>. You don’t have to do anything to make Python do this; it’s the way Python works.
                It saves a little processing time. And, as a special bonus, you can take advantage of Python’s short-circuiting behavior
                to shorten your code. Consider the following example:</paragraph>

    <program label="ac_logop_dangerous" interactive='activecode' language="python">
    
        <input>
total_weight = int(input('Enter total weight of luggage:'))
num_pieces = int(input('Number of pieces of luggage?'))

if total_weight / num_pieces &gt; 50:
   print('Average weight is greater than 50 pounds -&gt; $100 surcharge.')

print('Luggage check complete.')
        </input>
<tests>


</tests>

    </program>
            <paragraph>This code checks to see if the average weight of a given number of pieces of luggage is greater than 50 pounds. However,
                there is a potential crash situation here. If the user enters <literal>0</literal> for <literal>num_pieces</literal>, the program will crash with a
                divide by zero error. Try it out to see it happen.</paragraph>
            <paragraph>To prevent the crash, you might add an extra if statement to check for zero:</paragraph>
            <literal_block force="False" language="default" linenos="False" xml:space="preserve">if num_pieces != 0:
   if total_weight / num_pieces &gt; 50:
      print('Average weight is greater than 50 pounds -&gt; $100 surcharge.')</literal_block>
            <paragraph>Now, the division will not occur if <literal>num_pieces</literal> is zero, and a potential runtime crash has been averted. Good job!</paragraph>
            <paragraph>We can shorten this example to a single <literal>if</literal> statement if we do it carefully. Anytime you have two nested <literal>if</literal>
                statements as in the example above, you can combine them into a single <literal>if</literal> statement by joining the conditions using
                the <literal>and</literal> operator. Consider the version below, and think about why this <literal>if</literal> statement is equivalent in its behavior to
                the previous version with two nested <literal>if</literal> statements:</paragraph>

    <program label="ac_logop_smarteval" interactive='activecode' language="python">
    
        <input>
total_weight = int(input('Enter total weight of luggage:'))
num_pieces = int(input('Number of pieces of luggage?'))

if num_pieces != 0 and total_weight / num_pieces &gt; 50:
   print('Average weight is greater than 50 pounds -&gt; $100 surcharge.')

print('Luggage check complete.')
        </input>
<tests>


</tests>

    </program>
            <paragraph>But wait a minute: is this code safe? Try running the program and entering the value <literal>500</literal> for <literal>total_weight</literal> and the value <literal>5</literal> for num_pieces.
                Then, try it again using the value <literal>0</literal> for num_pieces. There should be no crash.</paragraph>
            <paragraph>Next, try altering the code and reversing the order of the <literal>if</literal> conditions:</paragraph>
            <literal_block force="False" language="default" linenos="False" xml:space="preserve">if total_weight / num_pieces &gt; 50 and num_pieces != 0:
   print('Average weight is greater than 50 pounds -&gt; $100 surcharge.')</literal_block>
            <paragraph>Run the program again, performing the same two tests. This time, you should observe a crash when you enter <literal>0</literal> for
                num_pieces. Can you analyze why the first version did not crash, but the second one does?</paragraph>
            <paragraph>In the second version, when evaluating left-to-right, the division by zero occurs before Python evaluates the comparison
                <literal>num_pieces != 0</literal>. When joining two <literal>if</literal> statements into a single <literal>if</literal> statement, you must be sure to put the
                condition from the first <literal>if</literal> statement on the left-hand side of the <literal>and</literal> operator, and the other condition on the
                right-hand side, in order to get the same effect.</paragraph>
            <paragraph>To summarize this discussion on smart evaluation, keep in mind that when you are performing potentially dangerous
                operations in an <literal>if</literal> statement or <literal>while</literal> loop using boolean logic with <literal>and</literal> or <literal>or</literal>, order matters!</paragraph>
            <paragraph><strong>Check your understanding</strong></paragraph>

    <exercise label="question6_3_1">
        <statement>

            <paragraph>What is the correct Python expression for checking to see if a number stored in a variable x is between 0 and 5.</paragraph>

        </statement>
<choices>

            <choice >
                <statement>
                    <p>x &gt; 0 and &lt; 5</p>
                </statement>
                <feedback>
                    <p>Each comparison must be between exactly two values.  In this case the right-hand expression &lt; 5 lacks a value on its left.</p>
                </feedback>
            </choice>

            <choice correct='yes'>
                <statement>
                    <p>0 &lt; x &lt; 5</p>
                </statement>
                <feedback>
                    <p>Although most other programming languages do not allow this syntax, in Python, this syntax is allowed.  Even though it is possible to use this format, you should not use it all the time.  Instead, make multiple comparisons by using and or or.</p>
                </feedback>
            </choice>

            <choice >
                <statement>
                    <p>x &gt; 0 or x &lt; 5</p>
                </statement>
                <feedback>
                    <p>Although this is legal Python syntax, the expression is incorrect.  It will evaluate to true for all numbers that are either greater than 0 or less than 5.  Because all numbers are either greater than 0 or less than 5, this expression will always be True.</p>
                </feedback>
            </choice>

            <choice correct='yes'>
                <statement>
                    <p>x &gt; 0 and x &lt; 5</p>
                </statement>
                <feedback>
                    <p>Yes, with an ``and`` keyword both expressions must be true so the number must be greater than 0 an less than 5 for this expression to be true.</p>
                </feedback>
            </choice>
</choices>

    </exercise>

    <exercise label="question6_3_2">
        <statement>

            <paragraph>Which of the following may result in a crash at runtime if the user presses Enter without typing a response?</paragraph>
            <paragraph>Option A)</paragraph>
            <literal_block force="False" language="default" linenos="False" xml:space="preserve">yesno = input('Enter Yes or No:')
if yesno[0] == 'Y' and len(yesno) &gt; 0:
   print('Yes!')</literal_block>
            <paragraph>Option B)</paragraph>
            <literal_block force="False" language="default" linenos="False" xml:space="preserve">yesno = input('Enter Yes or No:')
if len(yesno) &gt; 0 and yesno[0] == 'Y':
   print('Yes!')</literal_block>

        </statement>
<choices>

            <choice correct='yes'>
                <statement>
                    <p>Option A</p>
                </statement>
                <feedback>
                    <p>Correct! The comparison yesno[0] == 'Y' will crash if yesno is an empty string.</p>
                </feedback>
            </choice>

            <choice >
                <statement>
                    <p>Option B</p>
                </statement>
                <feedback>
                    <p>Incorrect. If len(yesno) > 0 is False, the potentially unsafe comparison yesno[0] == 'Y' will not be evaluated.</p>
                </feedback>
            </choice>
</choices>

    </exercise>

    <exercise label="question6_3_3">
        <statement>

            <paragraph>Consider the following fragment containing a nested <literal>if</literal> statement to prevent a crash in the event
                the user enters an empty response for <literal>yesno</literal>:</paragraph>
            <literal_block force="False" language="default" linenos="False" xml:space="preserve">yesno = input('Enter Yes or No:')
if len(yesno) &gt; 0:
   if yesno[0] == 'Y':
      print('Yes!')</literal_block>
            <paragraph>Which of the following is the correct way to combine the nested <literal>if</literal> into a single <literal>if</literal> statement that executes
                identically to the nested <literal>if</literal> statements?</paragraph>
            <paragraph>Option A)</paragraph>
            <literal_block force="False" language="default" linenos="False" xml:space="preserve">if yesno[0] == 'Y' and len(yesno) &gt; 0:
   print('Yes!')</literal_block>
            <paragraph>Option B)</paragraph>
            <literal_block force="False" language="default" linenos="False" xml:space="preserve">if len(yesno) &gt; 0 and yesno[0] == 'Y':
   print('Yes!')</literal_block>
            <paragraph>Option C)</paragraph>
            <literal_block force="False" language="default" linenos="False" xml:space="preserve">if yesno[0] == 'Y' or len(yesno) &gt; 0:
   print('Yes!')</literal_block>
            <paragraph>Option D)</paragraph>
            <literal_block force="False" language="default" linenos="False" xml:space="preserve">if len(yesno) &gt; 0 or yesno[0] == 'Y':
   print('Yes!')</literal_block>

        </statement>
<choices>

            <choice >
                <statement>
                    <p>Option A</p>
                </statement>
                <feedback>
                    <p>Incorrect. The comparison yesno[0] == 'Y' will crash if yesno is an empty string.</p>
                </feedback>
            </choice>

            <choice correct='yes'>
                <statement>
                    <p>Option B</p>
                </statement>
                <feedback>
                    <p>Correct! Use the and operator to join nested if statements into a single statement, with the first if condition on the left-hand side.</p>
                </feedback>
            </choice>

            <choice >
                <statement>
                    <p>Option C</p>
                </statement>
                <feedback>
                    <p>Incorrect. The comparison yesno[0] == 'Y' will crash if yesno is an empty string.</p>
                </feedback>
            </choice>

            <choice >
                <statement>
                    <p>Option D</p>
                </statement>
                <feedback>
                    <p>Incorrect. The comparison yesno[0] == 'Y' will crash if yesno is an empty string.</p>
                </feedback>
            </choice>
</choices>

    </exercise>
        </section>
    </section>
</document>
