<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.19 -->
<document source="/Users/clatulip/Documents/RunestoneBooks/ThinkLikeComputer/_sources/GeneralIntro/FormalandNaturalLanguages.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <substitution_definition names="blank"><BlankNode></BlankNode></substitution_definition>
    <substitution_definition names="docname"><reference refuri="FormalandNaturalLanguages-source.html">FormalandNaturalLanguages</reference></substitution_definition>
    <comment xml:space="preserve">Copyright (C)  Brad Miller, David Ranum, Jeffrey Elkner, Peter Wentworth, Allen B. Downey, Chris
Meyers, and Dario Mitchell.  Permission is granted to copy, distribute
and/or modify this document under the terms of the GNU Free Documentation
License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being Forward, Prefaces, and
Contributor List, no Front-Cover Texts, and no Back-Cover Texts.  A copy of
the license is included in the section entitled "GNU Free Documentation
License".</comment>
    <index entries="['single',\ 'formal\ languages',\ 'index-0',\ '',\ None]" inline="False"></index>
    <target refid="index-0"></target>
    <section ids="formal-and-natural-languages index-0" names="formal\ and\ natural\ languages">
        <title>Formal and Natural Languages</title>
        <paragraph><strong>Natural languages</strong> are the languages that people speak, such as English,
            Spanish, Korean, and Mandarin Chinese. They were not designed by people (although people try to
            impose some order on them); they evolved naturally.</paragraph>
        <paragraph><strong>Formal languages</strong> are languages that are designed by people for specific
            applications. For example, the notation that mathematicians use is a formal
            language that is particularly good at denoting relationships among numbers and
            symbols. Chemists use a formal language to represent the chemical structure of
            molecules. And most importantly:</paragraph>
        <block_quote>
            <paragraph><emphasis>Programming languages are formal languages that have been designed to
                    express computations.</emphasis></paragraph>
        </block_quote>
        <paragraph>Formal languages tend to have strict rules about syntax. For example, <literal>3+3=6</literal>
            is a syntactically correct mathematical statement, but <literal>3=+6$</literal> is not.
            H<subscript>2</subscript>O is a syntactically correct chemical name, but <subscript>2</subscript>Zz is
            not.</paragraph>
        <paragraph>Syntax rules come in two flavors, pertaining to <strong>tokens</strong> and <strong>structure</strong>.
            Tokens are the basic elements of the language, such as words, numbers, and
            chemical elements. One of the problems with <literal>3=+6$</literal> is that <literal>$</literal> is not a
            legal token in mathematics (at least as far as we know). Similarly,
            <subscript>2</subscript>Zz is not legal because there is no element with the abbreviation
            <literal>Zz</literal>.</paragraph>
        <paragraph>The second type of syntax rule pertains to the <strong>structure</strong> of a statement—
            that is, the way the tokens are arranged. The statement <literal>3=+6$</literal> is
            structurally illegal because you can’t place a plus sign immediately after an
            equal sign.  Similarly, molecular formulas have to have subscripts after the
            element name, not before.</paragraph>
        <paragraph>When you read a sentence in English or a statement in a formal language, you
            have to figure out what the structure of the sentence is (although in a natural
            language you do this subconsciously). This process is called <strong>parsing</strong>.</paragraph>
        <paragraph>For example, when you hear the sentence, “The other shoe fell”, you understand
            that the other shoe is the subject and fell is the verb.  Once you have parsed
            a sentence, you can figure out what it means, or the <strong>semantics</strong> of the sentence.
            Assuming that you know what a shoe is and what it means to fall, you will
            understand the general implication of this sentence.</paragraph>
        <paragraph>Although formal and natural languages have many features in common — tokens,
            structure, syntax, and semantics — there are many differences:</paragraph>
        <glossary sorted="False">
            <definition_list classes="glossary">
                <definition_list_item>
                    <term ids="term-ambiguity">ambiguity<index entries="['single',\ 'ambiguity',\ 'term-ambiguity',\ 'main',\ None]"></index></term>
                    <definition>
                        <paragraph>Natural languages are full of ambiguity, which people deal with by
                            using contextual clues and other information. Formal languages are
                            designed to be nearly or completely unambiguous, which means that any
                            statement has exactly one meaning, regardless of context.</paragraph>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term ids="term-redundancy">redundancy<index entries="['single',\ 'redundancy',\ 'term-redundancy',\ 'main',\ None]"></index></term>
                    <definition>
                        <paragraph>In order to make up for ambiguity and reduce misunderstandings, natural
                            languages employ lots of redundancy. As a result, they are often
                            verbose.  Formal languages are less redundant and more concise.</paragraph>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term ids="term-literalness">literalness<index entries="['single',\ 'literalness',\ 'term-literalness',\ 'main',\ None]"></index></term>
                    <definition>
                        <paragraph>Formal languages mean exactly what they say.  On the other hand,
                            natural languages are full of idiom and metaphor. If someone says, “The
                            other shoe fell”, there is probably no shoe and nothing falling.</paragraph>
                        <tip>
                            <paragraph>You’ll need to find the original joke to understand the idiomatic
                                meaning of the other shoe falling.</paragraph>
                        </tip>
                    </definition>
                </definition_list_item>
            </definition_list>
        </glossary>
        <paragraph>People who grow up speaking a natural language—that is, everyone—often have a hard
            time adjusting to formal languages. In some ways, the difference between natural and formal
            language is like the difference between poetry and prose, but more
            so:</paragraph>
        <glossary sorted="False">
            <definition_list classes="glossary">
                <definition_list_item>
                    <term ids="term-poetry">poetry<index entries="['single',\ 'poetry',\ 'term-poetry',\ 'main',\ None]"></index></term>
                    <definition>
                        <paragraph>Words are used for their sounds as well as for their meaning, and the
                            whole poem together creates an effect or emotional response. Ambiguity is not only common but often deliberate.</paragraph>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term ids="term-prose">prose<index entries="['single',\ 'prose',\ 'term-prose',\ 'main',\ None]"></index></term>
                    <definition>
                        <paragraph>The literal meaning of words is more important, and the structure contributes more meaning. Prose is more amenable to analysis than poetry but still often ambiguous.</paragraph>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term ids="term-program">program<index entries="['single',\ 'program',\ 'term-program',\ 'main',\ None]"></index></term>
                    <definition>
                        <paragraph>The meaning of a computer program is unambiguous and literal, and can be understood entirely by analysis of the tokens and structure.</paragraph>
                    </definition>
                </definition_list_item>
            </definition_list>
        </glossary>
        <paragraph>Here are some suggestions for reading programs (and other formal languages).
            First, remember that formal languages are much more dense than natural
            languages, so it takes longer to read them. Also, the structure is very
            important, so it is usually not a good idea to read from top to bottom, left to
            right. Instead, learn to parse the program in your head, identifying the tokens
            and interpreting the structure.  Finally, the details matter. Little things
            like indentation, spelling errors and bad punctuation, which you can get away with in natural languages, can make a big difference in a formal language.</paragraph>
        <paragraph><strong>Check your understanding</strong></paragraph>

    <exercise label="question_natural_vs_formal">
        <statement>

        <paragraph>The differences between natural and formal languages include:</paragraph>

        </statement>
<choices>

            <choice >
                <statement>
                    <p>natural languages can be parsed while formal languages cannot.</p>
                </statement>
                <feedback>
                    <p>Actually both languages can be parsed (determining the structure of the sentence), but formal languages can be parsed more easily in software.</p>
                </feedback>
            </choice>

            <choice correct='yes'>
                <statement>
                    <p>ambiguity, redundancy, and literalness.</p>
                </statement>
                <feedback>
                    <p>All of these can be present in natural languages, but cannot exist in formal languages.</p>
                </feedback>
            </choice>

            <choice >
                <statement>
                    <p>there are no differences between natural and formal languages.</p>
                </statement>
                <feedback>
                    <p>There are several differences between the two but they are also similar.</p>
                </feedback>
            </choice>

            <choice >
                <statement>
                    <p>tokens, structure, syntax, and semantics.</p>
                </statement>
                <feedback>
                    <p>These are the similarities between the two.</p>
                </feedback>
            </choice>
</choices>

    </exercise>

    <exercise label="question_readingTF">
        <statement>

        <paragraph>True or False:  Reading a program is like reading other kinds of text.</paragraph>

        </statement>
<choices>

            <choice >
                <statement>
                    <p>True</p>
                </statement>
                <feedback>
                    <p>It usually takes longer to read a program because the structure is as important as the content and must be interpreted in smaller pieces for understanding.</p>
                </feedback>
            </choice>

            <choice correct='yes'>
                <statement>
                    <p>False</p>
                </statement>
                <feedback>
                    <p>It usually takes longer to read a program because the structure is as important as the content and must be interpreted in smaller pieces for understanding.</p>
                </feedback>
            </choice>
</choices>

    </exercise>
    </section>
</document>
